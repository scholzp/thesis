\chapter{Related Work}
\label{chap:related}

In the following sections we will see multiple implementations of CPU vendors,
learn about \glspl{tpm} and how a software solution can look. All of them serve
as input for my implementation.

\section{Intel SGX}
\label{sec:20:sgx}
\todo{A lot of passive to fix here}
Intel SGX is an extension in x86\_64 processors manufactured by Intel, that
allows the creation of trusted execution environments. Intel first shipped SGX
in 2015, with processors implementing the Skylake microarchitecture. While
server-grade CPUs are still implementing SGX, Intel marked SGX was deprecated in
2021 in consumer-grade CPUs, beginning from CPUs implementing the Rocket Lake
microarchitecture. Costan et al. did an extensive study of SGX in 2016 and
documented in detail how SGX works and what it's security properties
are.\cite{costan2016intel} \\

Features of SGX include the creation of enclaves. Enclaves are especially
access-protected and encrypted system memory regions, with SGX preventing direct
memory access. In the creation process, memory pages are added to the enclave
page cache (EPC) and assigned to the enclave. Once assigned to an enclave, SGX
protects the memory page from unprivileged access, which includes all access
attempts not originating from the memory-owning enclave. After the system
software adds all pages to the enclave, it is marked as initialized. For the
initialization process, system software uses privileged instructions. After the
enclave is marked initialized, no more pages can be added to the EPC, and
interaction with the enclave is only allowed by using dedicated instructions
available only in user space. The EPC is similar to an inverted page table,
which purpose is to protect an enclaves security by ensuring the correctness of
the allocation process. SGX would, for example, refuse operation if it detects
that the same page frame was used for two different enclaves.\\

The enclave code runs at the permission level of
the application from which the enclave was called. Intel equips each CPU with
unique cryptographic keys that the CPU uses to encrypt code and data placed in
the EPC. These keys reside in memory made of electronic fuses that can not be
reprogrammed. Intel programs this memory in the factory process by burning some
of the fuses. Applications using SGX services do not necessarily need to run as
a whole in an SGX enclave. Because of restrictions on the size of the enclave's
memory, only parts of the data were handed to enclaves. Again, communications
between the enclave and user applications use special CPU instructions. In cases
where applications are split into parts residing in and outside of the enclave,
an application might want to verify the identity before sharing secrets. For
this, SGX implements local attestation.\\

As mentioned, SGX implements processor instructions dedicated to managing and
interacting with enclaves. Furthermore, SGX implementations create at least a
Launch Enclave signed by Intel. Third party enclaves that are not signed by
Intel require the Launch Enclave for successful initialization. It is necessary
in all cases when SGX is used.\\

An attesting enclave can verify its identity with another enclave in the same
system by generating a report. The attesting enclave calls the \textbf{ERPEORT}
instruction to generate this report. As a result, the CPU measures the attesting
enclave and generates a report that contains the measurement, the enclave's
identity, and a message provided by the enclave. The attesting enclave then
ships the generated report to another enclave for local attestation.
\begin{center}
    \begin{figure}
        \centering
        \includestandalone{images/25_sgx_attestation.tex}
        \caption{Software Attestation Scheme of SGX}
        \label{fig:state:tee:sgx_attestation}
    \end{figure}
\end{center}
Figure~\ref{fig:state:tee:sgx_attestation} shows the remote attestation scheme
implemented by Intel SGX. It extends the local attestation scheme so that a
third party not part of the system can verify the identity of an enclave. The
quoting enclave serves as a root of trust in this process. It is a unique
enclave provided by Intel that has access to the CPUs infused keys and can thus
act as a trust anchor. Upon receiving a report from another enclave, the quoting
enclave verifies said report and signs it. A remote third party can then check
the quoting enclave's signature to verify the correctness of the report..

\section{Confidential Virtual Machine Extensions}
\label{section:20:confidential_vms}
The goal of confidential Virtual machines is to protect the entire \gls{vm} from
the influence of a malicious hypervisor or other privileged software. Intel and
AMD offer individual \gls{isa} extensions for their processors to host
confidential Virtual Machines. Intel calls its solution Intel TDX, while AMDs
solution is called AMD SEV-SNP.\cite{tdx_whitepaper,kaplan_amd_2020} Both
solutions use the same fundamental building blocks to achieve the goals of
confidential \gls{vm}s. Misano et al. did a extensive comparison of both
technologies.\cite{misono_confidential_2024} Intel uses the SGX module for its
implementation. Additionally, to interact with a confidential \gls{vm}, the CPU
must be in the dedicated CPU operation mode called SEAM mode. Memory access is
only allowed in SEAM mode to protect confidential \gls{vm}s. Once in SEAM mode,
the CPU uses its Virtual Machine Extensions (VMX) capabilities to host and
interact with the \gls{vm}. For cryptographical features, such as signing and
key generation, Intel processors utilize the Intel Management Engine. The Intel
management Engine is a coprocessor located in the CPU package with special
firmware and a separate OS that is isolated from the remaining parts of the
system\\

For \gls{sev}, AMD uses the already implemented SEV capabilities and its
extensions. In its initial version SEV encrypts the memory of a virtual machine
with a dedicated key per virtual machine. SEV-ES extends the feature set by
additionally encrypting the system state, e.g. processor register, too. With the
most recent version, AMD introduced a feature called nested paging, which
manages an inverted page table similar to SGX to prevent attacks targeting the
\gls{vm}s page tables.\\

Unlike Intel's implementation, AMD processors do not utilize a dedicated CPU
mode but extend the existing \gls{vm} control structure by fields to enable
Secure Nested paging. For cryptography, the integrated AMD Platform Security
Processor, short PSP, is used. Both solutions encrypt the \gls{vm}'s memory to
protect the \gls{vm} from being manipulated by system software. While in Intel's
implementation, each \gls{vm} is encrypted separately, AMD's implementation
encrypts, once activated, the whole memory.\\

Both solutions use the trustee's knowledge of the initial state of the \gls{vm}
image. The assumption that the approach follows is that if the \gls{vm} is
started in a known state and protected from manipulation by the hypervisor or
other privileged software, then the \gls{vm} can be trusted in the following. To
follow this approach, a measurement of the initial \gls{vm} image is created and
cryptographically bound to the respective \gls{vm} instance through a message
authentication code. Before the trustee interacts with the \gls{vm}, they
request the \gls{vm} to verify its identity. For this, the \gls{vm} requests the
cryptographical hardware to sign a report. By signing the report, the
cryptographic hardware attests to its correctness and then hands it to the
trustee. The trustee trusts the implementation in the CPU and verifies the
signature of the CPU signed report. With this, the trustee knows if the \gls{vm}
images were expected. In the following, both the trustee and the \gls{vm}
exchange keys for further communication.\\

\section{ARM TrustZone}
\label{sec:20:trustzone}
As another widely spread ISA ARM dominates the mobile sector. Like x86, the ARM
architecture offers technology to allow isolated program execution. On ARM, this
technology is called ARM TrustZone. TrustZone is optional for ARM processor
implementations and slightly differs between the ARM Cortex-A application
processors and the ARM Cortex-M microcontroller-aimed processors. In the
following, we concentrate on the implementation of ARM application
processors. Pinto and Santos did an extensive survey of ARM TrustZone in 2019.
In their work, they describe technical properties of AMR TrustZone and how to
use it for the implementation of \glspl{tee} and hypervisors. Moreover they
explain technical details of Trustzone and review it's security properties
against other \glspl{tee}.\cite{pinto_demystifying_2019}\\

Conceptually, ARM TrustZone-enabled processors offer three processor operation
modes. The most privileged mode is the Secure Monitor mode or short SM mode. The
Secure Monitor mode is the mode in which the processor boots and the firmware
and Bootloader executes. The second most privileged mode is the Secure World.
This mode is intended to execute code isolated from the third and least
privileged mode, the Normal World. The Bootloader is responsible for installing
software intended to run in the Secure World. Isolation is achieved by hardware.
For example, the stack pointer (SP) and return address (LR) registers exist
twice to allow fast context switches between the Normal and Secure World. The
TrustZone Address Space Controller can be used to partition memory into regions
only accessible from the Secure World and those accessible by both worlds.
Changing between worlds can be done synchronously using the dedicated SMC
(System Monitor Call) instruction or asynchronously due to an interrupt. The SMC
instruction also triggers an interrupt. These interrupts are served by invoking
the SM, which decides upon its configuration if the interrupt received serves as
an entry point to the secure world. If so, the Secure Monitor invokes secure
world code to serve the interrupt.\\

ARM TrustZone does not specify the TEE and remote attestation features. Such
functionality has to be implemented by the code running in the Secure World and
might the implementation of those features might be specific to system or
hardware vendors. TEE and remote attestation functionality can be implemented by
a bare metal application or by using a trusted OS to host secure applications in
the Secure World. The first solution minimizes code size, while the second
offers the ability to host multiple applications in the Secure World. The
trusted OS would be responsible for isolating services running in the Secure
World against each other because applications running in the Secure World are
not isolated from other applications in the Secure World by hardware. Using a
trusted OS brings the downside of an increased trusted computing base compared
to a bare metal trusted application. TrustZone does not encrypt the memory of
the secure world, instead it utilizes the physical isolation of both worlds.\\

\section{Enma}
\label{sec:20:enma}
Enma is short for Enclave Manager and is a software solution to implement TEEs
for the L4Re operating system framework. \cite{reitz_isolierende_2019} L4Re uses
the Fiasco.OC microkernel that is part of the L4 microkernel family. The
microkernel approach aims for minimizing the amount of code to run in the
supervisor mode. The creator of L4 defined the concept of microkernels as
follows:

\begin{quote}
    \textit{ More precisely, a concept is tolerated inside the \mu-kernel only
        if moving it outside the kernel, i.e., permitting competing
        implementations, would prevent the implementation of the system's
        required functionality. \\
    } \mbox{ -- Liedke\cite{liedtke1995micro}}
\end{quote}

Following this philosophy, Fiasco.OC only implements the mere minimal services.
All other services, such as memory management, are implemented as user space
applications. The minimal setup of a L4Re system consists of the Fiasco.OC
kernel, Sigma0, which manages memory, and root task moe, which is responsible
for loading applications. As a capability based system, the kernel ensures that
only applications with the right capabilities have access to process memory.
Initially, only the creator of a process posses these capabilities and the
ability to grant them to other processes. Enma uses these properties to create
isolated enclaves in which programs can execute isolated.\\

Enma follows the same approach as SGX for implementing remote attestation. Enma
hosts a quoting enclave that sings reports to verify the state of an enclave.
The appraiser can then check the signature of the quoting enclave, upon which
they decide how to interact with the enclave. Enma encrypts the memory of its
enclaves. Security-wise, Enma is vulnerable to side-channel attacks as
explicitly stated in the work. The TCB is also increased when compared to
hardware solutions. An application that trusts Enma must also trust the L4Re
runtime environment as much as the firmware and hardware. Enma utilizes a
\gls{tpm} as the hardware root of trust for verifying the system state and that
the expected versions of L4Re and Enma were booted. The soft backend of Enma,
which I described in this section, can also be replaced by another backend. The
authors propose an SGX back end that utilizes hardware features

\section{Attack Mitigations and countermeasures}
\label{sec:20:mitigations}
In this section I want to list review mitigations and countermeasures for known
side channel attacks. These mitigations and countermeasures serve as examples
for my implementation and can be viewed as part of related work, as they show
how to either detect or prevent the usage of side channels and attacks that
utilize them.

\subsection{Isolation through SMM}
\label{sec:20:isolation_smm}
An early work on how to isolate processes was done by Azab et al. in
2011.\cite{azab_sice_2011} The work dates before introducing TEE extensions in
x86 hardware and uses the SMM to isolate tasks. The problem SICE tries to solve
is to protect the memory integrity of isolated tasks and virtual machines. In
principle, SICE uses the strong hardware-enforced isolation of the SMM and its
SMRAM to install applications into it. The authors used an AMD platform for
their practical implementation because AMD platforms allow the adjustment of
SMRAM size and location after the SMM code locks the SMRAM.\cite{bios2014amd} To
switch to the isolated task residing in SMRAM, the firmware SMI handler was
modified to transfer control to the management runtime of the isolation
environment. The strong hardware isolation guaranteed that even a malicious
operating system could not access the memory of the isolated task. A downside to
this approach is that it works only on a small amount of hardware. The
implementation depends on the resizeable SMRAM to react to the growing memory
demands of applications isolated through SICE. As the authors mentioned, they
used AMD platforms for their implementation because of this. Intel platforms did
not support this feature, and adapting SICE to those platforms was left as an
open problem. Moreover, firmware modifications have to be implemented by the
user to install the correct SMI handler. These modifications require the
firmware to be open source to implement the SMI handler. This requirement
further reduces the amount of hardware used for this approach. Moreover the
authors state that practical deployment would require CPU and hardware vendors
to do extensive security reviews on their firmware and SMM implementations.
Additionally, multiple attacks are known targeting the SMM breaking it's
isolation.\cite{wojtczuk2014attacking, wojtczuk2009attacking, wojtczuk2009poisining}

\subsection{Defenses Against Interrupt Based Side Channel Attacks}
\label{sec:20:interrupt_sca}
To defend against interrupt-based side-channel attacks, Cui et al. proposed a
defense solution in 2023 that they call QuanShield.\cite{cui_quanshield_2023}
QuanShield goal is to enable SGX enclaves to detect interrupt-based side-channel
attacks and react adequately. For this, QuanShield isolates a CPU core from the
system to let it run an Intel SGX enclave. The goal of the isolation is to
prevent the scheduler from interrupting the isolated core because no other
workload is to be executed by this core. The authors turned off all other
interrupts as far as possible. The authors used a Linux kernel that runs in
tickless mode to ensure that the kernel does not send scheduling interrupts to
the isolated core. The authors built tickless kernels by using the kernel
KConfig option \textit{CONFIG\_NO\_HZ\_FULL=y}. In this mode, the kernel does
not send scheduling interrupts to cores that are either idle or for which only
one task is ready.\cite{linuxtickless} All remaining interrupts are considered
to be attacks on the enclave. QuanShield uses unused parts of the state save
area to terminate the enclave upon receiving any interrupt. The state save area
is protected enclave memory in which the CPU stores its state on context
switches, e.g., when stopping to execute enclave code. QuanShield stores
non-canonical memory addresses in these unused parts. Once the control returns,
the enclave code uses one of these non-canonical addresses, which results in a
CPU exception and leads to the termination of the enclave, effectively stopping
the attack.\\

QuanShield uses code instrumentation to make the enclave use one of the
manipulated addresses. For this, the authors added code to the LLVM compiler.
The compiler introduces load and store operations on each function entry to make
the code fault as fast as possible. QuanShield uses a library OS to support
legacy applications. It implements the protection mechanism by utilizing SGX-LKL
to manage the second stack in the state save area. SGX-LKL is a Linux kernel
port that can run in an SGX enclave as a LibraryOS, similar to the approach used
by SCONE and Haven to mitigate effects of Iago attacks, which I just want to
name as a side node because these solutions are less relevant for this
work.\cite{priebe2019sgx,arnautov_scone_2016,baumann_shielding_2015,
    checkoway2013iago}

\subsection{Transient Execution Mitigations}
\label{sec:20:def_sca}
Because Spectre and Meltdown target microarchitectural behavior, a complete
redesign is necessary to entirely fix the issue. Software mitigations are
available for specific attacks. For example, the Linux Kernel uses techniques
called Retpoline and Kernel Page Table Isolation (KPTI) to mitigate Spectre
version 2 and Meltdown, respectively.\cite{retpoline} On the other hand, software mitigations
can greatly impact performance, reaching from a 10\% to 800\% overhead,
depending on the workload.\cite{low2018overview}\\

Another approach for systems to defend against side-channel attacks, in general,
is active detection of the attack and reacting appropriately. Quanshield
implements such a solution for interrupt-based side channel attacks described in
chapter~\ref{sec:20:interrupt_sca}. For attacks abusing transient execution,
this approach of deactivating transient execution would come with a
high-performance penalty.\\

Instead, existing solutions attempt to monitor the
cache and other microarchitectural behavior through hardware performance
counters to find any anomaly. The idea behind this approach is that a program
shows specific behavior. This behavior results from the instructions it executes
and their order, which leaves a kind of footprint. When monitoring the hardware
performance counters closely enough, the observer can deduce what parts of code
have been executed by the CPU. If the performance counter traces of the program
are known beforehand, an Observer can compare the values of the counters with
the known state and then reason if the control flow was highjacked, for example,
by an ROP attack. As a side note, monitoring through hardware Performance
counters can also be used for attacks, which is why performance counters are
unavailable while the CPU operates in SGX mode.
\cite{uhsadel2008exploiting,costan2016intel}

Like ROP attacks, transient execution attacks show special behavior when
preparing the attack or side channel. Li et al. and Van Bulck et al. examined
how to trace the behavior of transient execution attacks with performance
counters on the examples of Spectre and Load Value injection attacks,
respectivley.\cite{li_detecting_2021, van_bulck_lvi_2020}
They found that when in the preparation phase, while the attacker trains the
branch predictor, fewer instructions are retired compared to typical workloads.
Moreover, employing the cache side channel leaves traces, too. For a cache-based
side-channel to work, the attacker tries to evict pages that map to addresses
they want to use for the attack. This results in a high amount of TLB flushes.
Later addresses are accessed by the side channel code to retrieve information.
Because the cache was flushed, the number of cache misses increased
significantly. An observer can detect all of these side effects by using
performance counters. Still, an attacker can hide their activities by slowing
down their attack. While the total number of cache misses induced by the attack,
for example, does not change this way, the attack distributes the misses more
evenly over time. Because events such as cache misses and TLB flushes are normal
behavior of a running system, the environment in which an attack runs introduces
noise that can help hide an attack. Thus, detecting said attack becomes nearly
impossible if an attacker distributes the effects of their attack over time.
Consequently, the results of Li et al. and Van Bulck et al. lead us to conclude
that a detection approach using hardware performance counters in this way is
unreliable. Kosasih et al. came to a similar conclusion in their survey of
knowledge in 2024.\cite{kosasih2024sok}

\section{Summary}
\label{sec:20:summary}
Next to the introduction to the technical aspects of x86 processors, we have seen
examples for \glspl{tee}, attacks on \glspl{tee}, and possible mitigations to
those attacks. \\

All \gls{tee} solutions have in common that they do not implement the whole
functionality exclusively in hardware. For example, Intel and AMD employ
dedicated security processors in their x86 \gls{soc} to implement \gls{sgx} and
\gls{sev} features, respectively. Together with Enma, which uses the \gls{tpm}
as a root of trust, these solutions implement a signature-based remote
attestation scheme. Next, they all share the property of being vulnerable to
side-channel attacks, with Spectre and Meltdown being rather prominent. These
attacks abuse observable (micro-) architectural side effects to leak secrets
through covert channels. Mitigations for some attacks exist, but they impact
performance or cannot be applied to all side-channel attacks. Additionally,
systems can observe these side effects through \glspl{pmc} to some degree, but
as we have seen in section~\ref{sec:20:def_sca}, attacks can avoid being
detected through reducing their throughput or simply if the noise in the the
system is too high. With QuanShield interrupt, based side channels were
mitigated by Cui et al. by creating an interrupt-free environment, which at
least mitigates this attack vector for \gls{sgx}.\\

Putting these together, I identified an approach that was not tested to the best
of my knowledge. This excludes architectural side channels by creating a
completely isolated execution environment that only uses core local resources
and monitors its integrity by utilizing \glspl{pmc}. How to design such an
\gls{tee} will be topic in chapter~\ref{sec:design}.


\cleardoublepage


%%% Local Variables:
%%% TeX-master: "diplom"
%%% End:
