\section{Trusted Execution Environments}
\label{sec:state:tee}
% \begin{figure}
%     \begin{tikzpicture}
%         \draw (1,0) -- (0,0) -- (0,1) -- cycle;
%     \end{tikzpicture}
%     \caption{Tikz test}
% \end{figure}

Suppose we are the developers of the messenger Signal. While we aim to implement a mechanism for automatic contact
discovery, we also want to follow our claims to ensure the privacy of communication for our users. This is because we do not
want to learn who is communicating with whom, nor do we want to learn about the communication itself.

While we could encrypt our users' phonebooks before uploading them to our servers for processing, encryption
alone is not enough to fulfill our privacy claims. For example, through encryption alone, the user is not able to
verify that they are communicating with a Signal server. While this problem could be solved with cryptographic
signatures, the user is still not able to verify that the server application is the expected one. For example, if
the Signal Foundation was malicious, it could install an application designed to spy on the communication. In another
scenario, the Signal server application could fall victim to malicious privileged entities.
Maintenance personnel with access to the server hardware could tap the memory bus. Privileged software, such as operating
systems or hypervisors, could manipulate the memory of the server application in a way that leaks information or
simply reads the memory containing all secrets. It is, therefore, necessary to protect not only the communication channels
between user and server but also the integrity and confidentiality of the server application. Moreover, the user should
be able to verify these claims on the server application.

The latter is the goal of remote attestation, a feature offered by many Trusted Execution Environments to verify that
software is executed as intended and that no information leak is possible. For TEEs to work, a system must contain a
so-called hardware root of trust. A hardware root of trust is a device that is self-protecting on the hardware level,
unable to be
modified even by privileged software, and often implementing cryptographic functions. Different solutions exist to
implement the functionality of Trusted Execution Environments. The following section will give us an overview of these
solutions.

\todo{Explain measurements, how the majority implements RA}

\subsection{Hardware Root of Trust}
\subsubsection{TPM}

\subsubsection{Intel SGX}
\todo{A lot of passive to fix here}
Intel SGX is an extension in some x86\_64 processors manufactured by Intel. Intel first shipped SGX in 2015, with
processors implementing the Skylake microarchitecture. While server-grade CPUs are still implementing SGX, Intel marked
SGX was deprecated in 2021 in consumer-grade CPUs, beginning from CPUs implementing the Rocket Lake microarchitecture.
Costan et al. did an extensive review of SGX in 2016.\cite{costan2016intel}

Features of SGX include the creation of so-called enclaves. Enclaves are especially access-protected and encrypted
system memory regions, with SGX preventing direct memory access. In the creation process, memory pages are
added to the so-called enclave page cache (EPC) and assigned to the enclave. Once assigned to an enclave, SGX protects
the memory page from unprivileged access, which includes all access attempts not originating from the memory-owning
enclave. After the system software adds all pages to the enclave, it is marked as initialized. For the initialization
process, system software uses highly privileged instructions. After the enclave is marked initialized, no more pages
can be added to the EPC, and interaction with the
enclave is only allowed by using dedicated instructions available only in user space. The enclave code runs at the
permission level of the application from which the enclave was called. Data and code added to the EPC are encrypted
using keys burned into the CPU hardware via e-fuses. Applications using SGX services do not necessarily need to run as a
whole in an SGX enclave. Because of restrictions on the size of the enclave's memory, only parts of the data were handed
to enclaves. Again, communications between the enclave and user applications use special CPU instructions. In cases where
applications are split into parts residing in and outside of the enclave, an application might want to verify the identity
before sharing secrets. For this, SGX implements so-called local attestation.

As mentioned, SGX implements processor instructions dedicated to managing and interacting with enclaves. Furthermore,
SGX implementations create at least a so-called Launch Enclave signed by Intel. The Launch Enclave is a
requirement for the successful initialization of enclaves, which Intel does not provide. It is necessary in all cases when SGX
is used.

To implement software attestation, SGX uses a second enclave provided by Intel, the so-called Quoting Enclave. The
quoting enclave is used to verify the state of an enclave to verify. This is done by generating a report structure. This
structure contains data such as the version and launch state of the enclave and its identity. It is generated by calling
the dedicated \textbf{EREPORT} instruction, which cryptographically binds the generated report structure to the enclave.
The generated report structure is handed to the quoting enclave for remote attestation. The quoting enclave then uses
private keys to sign the report to attest that the report was indeed generated from the enclave in question. A remote
party can check the quoting enclave's signature to verify the enclave's state and identity.

\subsubsection{Confidential VM Extensions}
\subsubsection{ARM TrustZone}
