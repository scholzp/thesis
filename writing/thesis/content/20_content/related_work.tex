\section{Attack Mitigations and countermeasures}
\label{sec:20:mitigations}
In this section I want to list review mitigations and countermeasures for known
side channel attacks. These mitigations and countermeasures serve as examples
for my implementation and can be viewed as part of related work, as they show
how to either detect or prevent the usage of side channels and attacks that
utilize them.

\subsection{Isolation through SMM}
\label{sec:20:isolation_smm}
An early work on how to isolate processes was done by Azab et al. in
2011.\cite{azab_sice_2011} The work dates before introducing TEE extensions in
x86 hardware and uses the SMM to isolate tasks. The problem SICE tries to solve
is to protect the memory integrity of isolated tasks and virtual machines. In
principle, SICE uses the strong hardware-enforced isolation of the SMM and its
SMRAM to install applications into it. The authors used an AMD platform for
their practical implementation because AMD platforms allow the adjustment of
SMRAM size and location after the SMM code locks the SMRAM.\cite{bios2014amd} To
switch to the isolated task residing in SMRAM, the firmware SMI handler was
modified to transfer control to the management runtime of the isolation
environment. The strong hardware isolation guaranteed that even a malicious
operating system could not access the memory of the isolated task. A downside to
this approach is that it works only on a small amount of hardware. The
implementation depends on the resizeable SMRAM to react to the growing memory
demands of applications isolated through SICE. As the authors mentioned, they
used AMD platforms for their implementation because of this. Intel platforms did
not support this feature, and adapting SICE to those platforms was left as an
open problem. Moreover, firmware modifications have to be implemented by the
user to install the correct SMI handler. These modifications require the
firmware to be open source to implement the SMI handler. This requirement
further reduces the amount of hardware used for this approach. Moreover the
authors state that practical deployment would require CPU and hardware vendors
to do extensive security reviews on their firmware and SMM implementations.
Additionally, multiple attacks are known targeting the SMM breaking it's
isolation.\cite{wojtczuk2014attacking, wojtczuk2009attacking, wojtczuk2009poisining}

\subsection{Defenses Against Interrupt Based Side Channel Attacks}
\label{sec:20:interrupt_sca}
To defend against interrupt-based side-channel attacks, Cui et al. proposed a
defense solution in 2023 that they call QuanShield.\cite{cui_quanshield_2023}
QuanShield goal is to enable SGX enclaves to detect interrupt-based side-channel
attacks and react adequately. For this, QuanShield isolates a CPU core from the
system to let it run an Intel SGX enclave. The goal of the isolation is to
prevent the scheduler from interrupting the isolated core because no other
workload is to be executed by this core. The authors turned off all other
interrupts as far as possible. The authors used a Linux kernel that runs in
tickless mode to ensure that the kernel does not send scheduling interrupts to
the isolated core. The authors built tickless kernels by using the kernel
KConfig option \textit{CONFIG\_NO\_HZ\_FULL=y}. In this mode, the kernel does
not send scheduling interrupts to cores that are either idle or for which only
one task is ready.\cite{linuxtickless} All remaining interrupts are considered
to be attacks on the enclave. QuanShield uses unused parts of the state save
area to terminate the enclave upon receiving any interrupt. The state save area
is protected enclave memory in which the CPU stores its state on context
switches, e.g., when stopping to execute enclave code. QuanShield stores
non-canonical memory addresses in these unused parts. Once the control returns,
the enclave code uses one of these non-canonical addresses, which results in a
CPU exception and leads to the termination of the enclave, effectively stopping
the attack.\\

QuanShield uses code instrumentation to make the enclave use one of the
manipulated addresses. For this, the authors added code to the LLVM compiler.
The compiler introduces load and store operations on each function entry to make
the code fault as fast as possible. QuanShield uses a library OS to support
legacy applications. It implements the protection mechanism by utilizing SGX-LKL
to manage the second stack in the state save area. SGX-LKL is a Linux kernel
port that can run in an SGX enclave as a LibraryOS, similar to the approach used
by SCONE and Haven to mitigate effects of Iago attacks, which I just want to
name as a side node because these solutions are less relevant for this
work.\cite{priebe2019sgx,arnautov_scone_2016,baumann_shielding_2015,
    checkoway2013iago}

\subsection{Transient Execution Mitigations}
\label{sec:20:def_sca}
Because Spectre and Meltdown target microarchitectural behavior, a complete
redesign is necessary to entirely fix the issue. Software mitigations are
available for specific attacks. For example, the Linux Kernel uses techniques
called Retpoline and Kernel Page Table Isolation (KPTI) to mitigate Spectre
version 2 and Meltdown, respectively.\cite{retpoline} On the other hand, software mitigations
can greatly impact performance, reaching from a 10\% to 800\% overhead,
depending on the workload.\cite{low2018overview}\\

Another approach for systems to defend against side-channel attacks, in general,
is active detection of the attack and reacting appropriately. Quanshield
implements such a solution for interrupt-based side channel attacks described in
chapter~\ref{sec:20:interrupt_sca}. For attacks abusing transient execution,
this approach of deactivating transient execution would come with a
high-performance penalty.\\

Instead, existing solutions attempt to monitor the
cache and other microarchitectural behavior through hardware performance
counters to find any anomaly. The idea behind this approach is that a program
shows specific behavior. This behavior results from the instructions it executes
and their order, which leaves a kind of footprint. When monitoring the hardware
performance counters closely enough, the observer can deduce what parts of code
have been executed by the CPU. If the performance counter traces of the program
are known beforehand, an Observer can compare the values of the counters with
the known state and then reason if the control flow was highjacked, for example,
by an ROP attack. As a side note, monitoring through hardware Performance
counters can also be used for attacks, which is why performance counters are
unavailable while the CPU operates in SGX mode.
\cite{uhsadel2008exploiting,costan2016intel}

Like ROP attacks, transient execution attacks show special behavior when
preparing the attack or side channel. Li et al. and Van Bulck et al. examined
how to trace the behavior of transient execution attacks with performance
counters on the examples of Spectre and Load Value injection attacks,
respectivley.\cite{li_detecting_2021, van_bulck_lvi_2020}
They found that when in the preparation phase, while the attacker trains the
branch predictor, fewer instructions are retired compared to typical workloads.
Moreover, employing the cache side channel leaves traces, too. For a cache-based
side-channel to work, the attacker tries to evict pages that map to addresses
they want to use for the attack. This results in a high amount of TLB flushes.
Later addresses are accessed by the side channel code to retrieve information.
Because the cache was flushed, the number of cache misses increased
significantly. An observer can detect all of these side effects by using
performance counters. Still, an attacker can hide their activities by slowing
down their attack. While the total number of cache misses induced by the attack,
for example, does not change this way, the attack distributes the misses more
evenly over time. Because events such as cache misses and TLB flushes are normal
behavior of a running system, the environment in which an attack runs introduces
noise that can help hide an attack. Thus, detecting said attack becomes nearly
impossible if an attacker distributes the effects of their attack over time.
Consequently, the results of Li et al. and Van Bulck et al. lead us to conclude
that a detection approach using hardware performance counters in this way is
unreliable. Kosasih et al. came to a similar conclusion in their survey of
knowledge in 2024.\cite{kosasih2024sok}

