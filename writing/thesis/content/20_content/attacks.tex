\section{Side Channel Attacks}
\label{sec:20:attacks}
In this section I want to highlight some attacks on \gls{tee} implementations.
This section does not claim to be a review of all attacks out there targeting
\glspl{tee}. Instead, I want to give a short explanation of attacks that I try
to mitigate with my prototype implementation (c.f chapter 3 \todo{ref auf design}).

\subsection{Transient Execution Attacks}
\label{sec:20:transientattacks}
In 2018, researchers published the Spectre and Meltdown
attacks.\cite{kocher_spectre_2020, lipp_meltdown_2020} These attacks were the
first to exploit the side effects of transient execution in modern CPUs and
affected all commodity architectures. For example, CPUs of the vendors AMD,
Intel, Qualcomm, and other ARM designs were affected. This class of new
transient execution side-channel attacks abuses the speculative execution
feature of modern CPU and defines an entirely new class of attacks. Furthermore,
they are the first class of attacks that abuse microarchitectural bugs. We
review this class of attacks in more detail as I aim to implement a TEE that can
defend against such an attack.\\

Both attacks abuse a race condition between transient executed instructions and
memory access (Spectre) or exception delivery (Meltdown). In strictly sequential
instruction processing, each instruction would only be executed if the results
of the one before arrived. With speculative execution, the CPU executes
instructions before the results of previous instructions arrive. With branching
or exception delivery, this can lead to a race condition in which instructions
are executed before the branching decision is committed or an exception arrives.
Both attacks aim to make the window in which instructions are executed
speculatively as large as possible to observe the microarchitectural side
effects later. With carefully crafted code, these race conditions can be used to
access arbitrary memory (Meltdown) or memory readable by the attacked process
(Spectre). \\

Both attacks have in common the fact that they transmit data through a covert
channel. In the original attack descriptions, both attacks use a cache covert
channel to which they transfer data with the help of transient executed
instructions. The class of transient execution attacks is still highly relevant
today, with at At least five attacks have been published since 2023.
\cite{ormandy2023zenbleed,trujillo2023inception, moghimi2023downfall,ragab_ghostrace_2024, wilke2024tdxdown}
TEE solutions are affected, too, because these attacks enable attackers to read
arbitrary memory. The problem persists, and no solution exists to mitigate
transient execution attacks in general.\\

\subsection{Interrupt Based Attacks}
\label{sec:20:interrupt_sca}
In section~\ref{sec:20:transientattacks}, we have seen that data can be leaked
from various \gls{tee} implementations over side channels if an attacker can
interrupt a \gls{tee} in a high temporal resolution. With SGX-step Van et al.
presented the first framework with which an attacker can mount attacks on
\gls{sgx} with instruction-level granularity.\cite{van2017sgx} Next to the
aforementioned covered side channels, this allows the attacker to learn access
patterns of the \gls{tee} and tightly monitor its control flow. Wilke et al. and
Kou et al. implemented similar attacks for AMD and ARM
processors.\cite{wilke2023sev, kou2021load}\\

On x86 processors, the attack scheme uses the \gls{lapic}, while on ARM, it uses
a separate core to send inter-processor interrupts to overcome the boundaries
set by the two worlds in TrustZone. While Kou et al. use these interrupts to
mount high-precision flush+evict attacks, both x86 attacks additionally describe
how to monitor \gls{tee} behavior by manipulating the page tables of the
\gls{tee}. By setting the accessed bit to 0, the attacker can at least learn of
memory accesses on page granularity. All three attacks are, therefore, able to
break the security guarantees of the \gls{tee} while not granting an attacker
more power than the attacker model of the respective solution does.
