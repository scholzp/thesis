#include <linux/module.h>	/* Needed by all modules */
#include <linux/kernel.h>	/* Needed for KERN_INFO */
#include <linux/smp.h>	/* Needed for KERN_INFO */
#include <asm/uaccess.h>
#include <asm/io.h>
#include <asm/msr.h>
#include <asm/smp.h>
#include <asm/processor.h>
#include <asm/delay.h>
#include <asm/uaccess.h>
#include <linux/buffer_head.h>
#include <linux/fs.h>
/*
 * This header is generated by the make rule 'startup' and introduces an
 * array and an corresponding length denoting integer:
 * 	STARTUP_CODE 	 - Identifier of the Array
 *  STARTUP_CODE_len - Identifier of the length denoting integer
 * This array contains bytecode that starts the AP and brings it into 32bit 
 * mode, before jumping to the minimal kernel.
 * Definitions:
 * 	unsigned char STARTUP_CODE[];
 * 	unsigned int STARTUP_CODE_len;
 */
#include "startup_code.h"
#include "elf_reader.h"

MODULE_LICENSE("GPL");
struct file *file_open(const char *path, int flags, int rights) ;
// START_ADDRESS comes from make as -D compiler flag
const size_t AP_LOWMEM_ADDRESS = START_ADDRESS;
// currently 1 page. TODO: Make this also use configurable from nix 
const size_t AP_LOWMEM_SIZE = LOW_MEM_SIZE;
// APIC ID of the AP to use
const u8 AP_ID = 3;

int init_module(void)
{
	void __iomem *lowmem_region;
	unsigned int lowmem_offset = 0;
	pr_info("***KMOD: Hello world 1.\n");

	pr_info("***KMOD: Using address 0x%016lx\n", AP_LOWMEM_ADDRESS);
	// We should do a check, if we really *most likely* own enough memory
	pr_info("***KMOD: Startup code length in bytes: %d\n", STARTUP_CODE_len);
	if (STARTUP_CODE_len >= AP_LOWMEM_SIZE) {
		pr_crit("***KMOD: Startup code size exceeds reserved memory size of %lu Bytes!\n", AP_LOWMEM_SIZE);
		return -ENOMEM;
	}

	// Lets map the lowmem into kernel address space
	lowmem_region = ioremap(AP_LOWMEM_ADDRESS, AP_LOWMEM_SIZE);
	{
		loff_t offset = 0;
		ssize_t bytes_read = 0;
		elf32_file_t *elf_file= NULL;
		u8* bytewise = NULL;
		u64 entry_addr = 0;
		struct file *f = file_open("/tmp/tee_kernel", O_RDWR, 0);
		u8* buffer = kzalloc(1024 * 1024 * 1, GFP_KERNEL);  
		bytes_read = kernel_read(f, buffer, 1024 * 1024 * 1, &offset);
		pr_info("Read 1 MiB or less: %ld, Buffer address %p\n", bytes_read, buffer);
		for (int x = 0; x < 10; ++x) {
			pr_info("%x\n", buffer[x]);
		}
		elf_file = parse_elf32(buffer);
		pr_info("Parse result %p; Loadable size sum: %lu\n", elf_file, elf_file->loadable_segments_size); 
		entry_addr = load_elf32_segments(elf_file);
		pr_info("Physical entry address: %llx\n", entry_addr);
		bytewise = (u8*)(&entry_addr);
		for (u8 x = 0; x < 4; ++x) {
			pr_info("Byte %d of long jump target %02x\n", x, bytewise[3-x]);
			 STARTUP_CODE[STARTUP_CODE_len - 4 + x] = bytewise[x];
		}
	}

	// Copy startup code bytewise from arry to lowmem
	while (lowmem_offset < STARTUP_CODE_len) {
		iowrite8(STARTUP_CODE[lowmem_offset], lowmem_region + lowmem_offset);
		++lowmem_offset;
	}

	// Activate the AP
	{
		// send INIT IPI via LAPIC. Does not work for x2APIC mode
		u64 lapic_addr;
		void __iomem *lapic_page;
		unsigned long flags;
		size_t num_startups = 0;
		// int cpu;

		//Disable Interrupts because the following better does not get
		//interrupted...
		local_irq_save(flags);

		pr_info("***KMOD: I'm CPU %d of a total of %d CPUs.", smp_processor_id(), num_online_cpus());
		// Read the address from the APIC Base Address Register of the CPU
		rdmsrl(0x0000001b, lapic_addr);
		// Bits 12-51 contain the pages address. The lowest 12 bits contain
		// additional information about the APIC but are *NOT* part of the
		// address ~~> Mask them to get the address of the physical frame
		lapic_page = ioremap(lapic_addr & (~0xFFFu), 4096);
		
		// We now got the physical address mapped. Let's do the IPI
		pr_info("***KMOD: LAPIC ADDRESS: 0x%016llx MAPPED TO: 0x%016lx\n", lapic_addr & (~0xFFFu), ((size_t)lapic_page));
		pr_info("***KMOD: lapic ID 0x%08x\n", ioread32(lapic_page + 0x20) );
		pr_info("***KMOD: lapic version 0x%08x\n", ioread32(lapic_page + 0x30));

		// Clear APIC errors
		iowrite32(0 , lapic_page + 0x280);
		// Select AP
		iowrite32((ioread32(lapic_page + 0x310) & 0x00ffffff) | (AP_ID << 24), lapic_page + 0x310);
		// Trigger INIT IPI and wait for delivery
		iowrite32((ioread32(lapic_page + 0x300) & 0xfff00000) | 0x00C500, lapic_page + 0x300);
		do { __asm__ __volatile__ ("pause" : : : "memory"); } while (ioread32(lapic_page + 0x300) & (1 << 12));
		// Select AP again and deassert, then wait for delivery
		iowrite32((ioread32(lapic_page + 0x310) & 0x00ffffff) | (AP_ID << 24), lapic_page + 0x310);
		iowrite32((ioread32(lapic_page + 0x300) & 0xfff00000) | 0x008500, lapic_page + 0x300);
		do { __asm__ __volatile__ ("pause" : : : "memory"); } while (ioread32(lapic_page + 0x300) & (1 << 12));
		//Wait 10 ms
		udelay(10000);

		// send STARTUP IPI (twice)
		for(num_startups = 0; num_startups < 2; ++num_startups) {
			// Clear errors; Seclect AP; Trigger STARTUP IP; wait
			iowrite32(0, lapic_page + 0x280); 
			iowrite32((ioread32(lapic_page + 0x310) & 0x00ffffff) | (AP_ID << 24), lapic_page + 0x310);
			// set delivery mode to 0x6 (startup) and vector to 0xc8 (segment of reserved low mem)
			iowrite32((ioread32(lapic_page + 0x300) & 0xfff0f800) | 0x0006c8, lapic_page + 0x300);
			udelay(200);
			do { __asm__ __volatile__ ("pause" : : : "memory"); } while (ioread32(lapic_page + 0x300) & (1 << 12));
		}
		// Release ressources; Enable interrupts
		iounmap(lapic_page);
		local_irq_restore(flags);
	}
	// Wait for AP to output it's text
	udelay(10000);
	pr_info("***AP should now boot payload kernel.\n");
	pr_info("***KMOD: All done; quit\n");
	// Release lowmem
	iounmap(lowmem_region);
	
	return 0;
}

struct file *file_open(const char *path, int flags, int rights) 
{
    struct file *filp = NULL;

    int err = 0;

    filp = filp_open(path, flags, rights);
    if (IS_ERR(filp)) {
		pr_info("Error reading file!");
        err = PTR_ERR(filp);
        return NULL;
    }
    return filp;
}

void cleanup_module(void)
{
	printk(KERN_INFO "Goodbye world 1.\n");
}