#include <linux/module.h>	/* Needed by all modules */
#include <linux/kernel.h>	/* Needed for KERN_INFO */
#include <linux/smp.h>	/* Needed for KERN_INFO */
#include <asm/uaccess.h>
#include <asm/io.h>
#include <asm/msr.h>
#include <asm/smp.h>
#include <asm/processor.h>
#include <asm/delay.h>
#include <asm/uaccess.h>
#include <linux/buffer_head.h>
#include <linux/fs.h>

#include "chardev.h"
#include "elf_reader.h"
#include "mb2_bootinfo.h"
/*
 * This header is generated by the make rule 'startup' and introduces an
 * array and an corresponding length denoting integer:
 * 	STARTUP_CODE 	 - Identifier of the Array
 *  STARTUP_CODE_len - Identifier of the length denoting integer
 * This array contains bytecode that starts the AP and brings it into 32bit 
 * mode, before jumping to the minimal kernel.
 * Definitions:
 * 	unsigned char STARTUP_CODE[];
 * 	unsigned int STARTUP_CODE_len;
 */
#include "startup_code.h"
#include "tee_mgmt.h"
#include "lapic.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Pascal Scholz <pascal.scholz@cyberus-technology.de>");

struct file *file_open(const char *path, int flags, int rights);
void start_ap(void);
// START_ADDRESS comes from make as -D compiler flag
const size_t AP_LOWMEM_ADDRESS = START_ADDRESS;
// currently 1 page. TODO: Make this also use configurable from nix 
const size_t AP_LOWMEM_SIZE = LOW_MEM_SIZE;
// APIC ID of the AP to use
const u8 AP_ID = 3;
// pages to use for shared memory communication
struct page *shared_pages;  

int init_module(void)
{
	void __iomem *lowmem_region;
	unsigned int lowmem_offset = 0;
	struct mb2_mmap *mb2_bi_mmap = create_mb2_mmap();
	// TODO: Fix the hardcoding of the shared mem buf size.
	struct page *shared_mem = alloc_pages(GFP_KERNEL, 1);
	u64 multiboot_info_phys_addr = 0;
	u8* shared_virt = NULL;

	pr_info("***KMOD: Hello world 1.\n");

	pr_info("***KMOD: Using address 0x%016lx\n", AP_LOWMEM_ADDRESS);
	// We should do a check, if we really *most likely* own enough memory
	pr_info("***KMOD: Startup code length in bytes: %d\n", STARTUP_CODE_len);
	if (STARTUP_CODE_len >= AP_LOWMEM_SIZE) {
		pr_crit("***KMOD: Startup code size exceeds reserved memory size of %lu Bytes!\n", AP_LOWMEM_SIZE);
		return -ENOMEM;
	}

	// Lets map the lowmem into kernel address space
	lowmem_region = ioremap(AP_LOWMEM_ADDRESS, AP_LOWMEM_SIZE);
	{
		loff_t offset = 0;
		ssize_t bytes_read = 0;
		elf32_file_t *elf_file= NULL;
		u8* bytewise = NULL;
		u64 entry_addr = 0;
		struct file *f = file_open("/tmp/tee_kernel", O_RDWR, 0);
		u8* buffer = kzalloc(1024 * 1024 * 1, GFP_KERNEL);  
		bytes_read = kernel_read(f, buffer, 1024 * 1024 * 1, &offset);
		pr_info("Read 1 MiB or less: %ld, Buffer address %p\n", bytes_read, buffer);
		for (int x = 0; x < 10; ++x) {
			pr_info("%x\n", buffer[x]);
		}
		elf_file = parse_elf32(buffer);
		pr_info("Parse result %p; Loadable size sum: %lu\n", elf_file, elf_file->loadable_segments_size); 
		entry_addr = load_elf32_segments(elf_file);
		pr_info("Physical entry address: %llx\n", entry_addr);
		bytewise = (u8*)(&entry_addr);
		for (u8 x = 0; x < 4; ++x) {
			STARTUP_CODE[STARTUP_CODE_len - 4 + x] = bytewise[x];
		}
	}

	//prepare shared memory
	{
		u8* bytewise = NULL;
		shared_virt = kmap(shared_mem);
		u32 address_as_u32;
		mb2_mmap_add_entry(
			mb2_bi_mmap,
			create_mb2_mmap_entry(
				page_to_pfn(shared_mem) * 4096, // Physical address of the page
				4096, 							// TODO: Fix hardcoded value
				7 								// MB2 type for usable memory
			)
		);
		multiboot_info_phys_addr = create_mb2_boot_info(mb2_bi_mmap);
		if ((-0x1u) < multiboot_info_phys_addr)
		{
			pr_err("MB2 Bootinfo location above 4GiB! Aborting");
			return -ENOMEM;
		}
		pr_info("Multiboot info at physical address: 0x%01llx\n", multiboot_info_phys_addr);
		pr_info("Shared mem at physical address:     0x%01llx\n", page_to_pfn(shared_mem) * 4096ull);
		address_as_u32 = multiboot_info_phys_addr & 0xFFFFFFF; // Mask for saver cast???
		// Copy shared memory address to the respective location in the bootcode
		bytewise = (u8*)(&address_as_u32);
		for (u8 x = 0; x < 4; ++x)
		{
				STARTUP_CODE[STARTUP_CODE_len - 8 + x] = bytewise[x];
		}
	}

	// Copy startup code bytewise from array to lowmem
	while (lowmem_offset < STARTUP_CODE_len) {
		iowrite8(STARTUP_CODE[lowmem_offset], lowmem_region + lowmem_offset);
		++lowmem_offset;
	}

	setup_tee_irq_handler(shared_virt);
	// setup character device for communication
	init_tee_chardev();
	// Activate the AP
	start_ap();
	// Wait for AP to output it's text
	udelay(10000);
	pr_info("***AP should now boot payload kernel.\n");
	pr_info("***KMOD: Initialization successful\n");
	// Release lowmem
	iounmap(lowmem_region);
	
	return 0;
}

void start_ap(void) {
	unsigned long flags;

	local_irq_save(flags);

	lapic_init();

	lapic_send_init_ipi_waiting(3);
	lapic_send_init_ipi_waiting(3);

	//Wait 10 ms
	udelay(10000);

	lapic_send_startup_ipi_waiting(3);
	lapic_send_startup_ipi_waiting(3);
	local_irq_restore(flags);
}

struct file *file_open(const char *path, int flags, int rights) 
{
	struct file *filp = NULL;

	int err = 0;

	filp = filp_open(path, flags, rights);
	if (IS_ERR(filp)) {
		pr_info("Error reading file!");
		err = PTR_ERR(filp);
		return NULL;
	}
	return filp;
}

void cleanup_module(void)
{
	purge_tee_chardev();
	release_lapic();
	printk(KERN_INFO "Goodbye world 1.\n");
}