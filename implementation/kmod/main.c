#include <linux/module.h>	/* Needed by all modules */
#include <linux/kernel.h>	/* Needed for KERN_INFO */
#include <linux/smp.h>	/* Needed for KERN_INFO */
#include <asm/uaccess.h>
#include <asm/io.h>
#include <asm/msr.h>
#include <asm/smp.h>
#include <asm/processor.h>
#include <asm/delay.h>
#include <asm/uaccess.h>
#include <linux/buffer_head.h>
#include <linux/fs.h>

#include "chardev.h"
#include "elf_reader.h"
#include "mb2_bootinfo.h"
/*
 * This header is generated by the make rule 'startup' and introduces an
 * array and an corresponding length denoting integer:
 * 	STARTUP_CODE 	 - Identifier of the Array
 *  STARTUP_CODE_len - Identifier of the length denoting integer
 * This array contains bytecode that starts the AP and brings it into 32bit 
 * mode, before jumping to the minimal kernel.
 * Definitions:
 * 	unsigned char STARTUP_CODE[];
 * 	unsigned int STARTUP_CODE_len;
 */
#include "startup_code.h"
#include "tee_mgmt.h"

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Pascal Scholz <pascal.scholz@cyberus-technology.de>");

struct file *file_open(const char *path, int flags, int rights);
void start_ap(void);
// START_ADDRESS comes from make as -D compiler flag
const size_t AP_LOWMEM_ADDRESS = START_ADDRESS;
// currently 1 page. TODO: Make this also use configurable from nix 
const size_t AP_LOWMEM_SIZE = LOW_MEM_SIZE;
// APIC ID of the AP to use
const u8 AP_ID = 3;
// pages to use for shared memory communication
struct page *shared_pages;  

int init_module(void)
{
	void __iomem *lowmem_region;
	unsigned int lowmem_offset = 0;
	struct mb2_mmap *mb2_bi_mmap = create_mb2_mmap();
	// TODO: Fix the hardcoding of the shared mem buf size.
	struct page *shared_mem = alloc_pages(GFP_KERNEL, 1);
	u64 multiboot_info_phys_addr = 0;

	pr_info("***KMOD: Hello world 1.\n");

	pr_info("***KMOD: Using address 0x%016lx\n", AP_LOWMEM_ADDRESS);
	// We should do a check, if we really *most likely* own enough memory
	pr_info("***KMOD: Startup code length in bytes: %d\n", STARTUP_CODE_len);
	if (STARTUP_CODE_len >= AP_LOWMEM_SIZE) {
		pr_crit("***KMOD: Startup code size exceeds reserved memory size of %lu Bytes!\n", AP_LOWMEM_SIZE);
		return -ENOMEM;
	}

	// Lets map the lowmem into kernel address space
	lowmem_region = ioremap(AP_LOWMEM_ADDRESS, AP_LOWMEM_SIZE);
	{
		loff_t offset = 0;
		ssize_t bytes_read = 0;
		elf32_file_t *elf_file= NULL;
		u8* bytewise = NULL;
		u64 entry_addr = 0;
		struct file *f = file_open("/tmp/tee_kernel", O_RDWR, 0);
		u8* buffer = kzalloc(1024 * 1024 * 1, GFP_KERNEL);  
		bytes_read = kernel_read(f, buffer, 1024 * 1024 * 1, &offset);
		pr_info("Read 1 MiB or less: %ld, Buffer address %p\n", bytes_read, buffer);
		for (int x = 0; x < 10; ++x) {
			pr_info("%x\n", buffer[x]);
		}
		elf_file = parse_elf32(buffer);
		pr_info("Parse result %p; Loadable size sum: %lu\n", elf_file, elf_file->loadable_segments_size); 
		entry_addr = load_elf32_segments(elf_file);
		pr_info("Physical entry address: %llx\n", entry_addr);
		bytewise = (u8*)(&entry_addr);
		for (u8 x = 0; x < 4; ++x) {
			STARTUP_CODE[STARTUP_CODE_len - 4 + x] = bytewise[x];
		}
	}

	//prepare shared memory
	{
		u8* bytewise = NULL;
		u32 address_as_u32;
		mb2_mmap_add_entry(
			mb2_bi_mmap,
			create_mb2_mmap_entry(
				page_to_pfn(shared_mem) * 4096, // Physical address of the page
				4096, 							// TODO: Fix hardcoded value
				1 								// MB2 type for usable memory
			)
		);
		multiboot_info_phys_addr = create_mb2_boot_info(mb2_bi_mmap);
		if ((-0x1u) < multiboot_info_phys_addr)
		{
			pr_err("MB2 Bootinfo location above 4GiB! Aborting");
			return -ENOMEM;
		}
		pr_info("Created MMAP entry for shared memory at 0x%01llx!\n", multiboot_info_phys_addr);
		address_as_u32 = multiboot_info_phys_addr & 0xFFFFFFF; // Mask for saver cast???
		// Copy shared memory address to the respective location in the bootcode
		bytewise = (u8*)(&address_as_u32);
		for (u8 x = 0; x < 4; ++x)
		{
				STARTUP_CODE[STARTUP_CODE_len - 8 + x] = bytewise[x];
		}
	}

	// Copy startup code bytewise from array to lowmem
	while (lowmem_offset < STARTUP_CODE_len) {
		iowrite8(STARTUP_CODE[lowmem_offset], lowmem_region + lowmem_offset);
		++lowmem_offset;
	}

	// setup character device for communication
	init_tee_chardev();
	// Activate the AP
	start_ap();
	// Wait for AP to output it's text
	udelay(10000);
	setup_tee_irq_handler();
	pr_info("***AP should now boot payload kernel.\n");
	pr_info("***KMOD: Initialization successful\n");
	// Release lowmem
	iounmap(lowmem_region);
	
	return 0;
}

void start_ap(void) {
	// send INIT IPI via LAPIC. Does not work for x2APIC mode
	u64 lapic_addr;
	void __iomem *lapic_page;
	unsigned long flags;
	size_t num_startups = 0;
	// int cpu;

	//Disable Interrupts because the following better does not get
	//interrupted...
	local_irq_save(flags);

	pr_info("***KMOD: I'm CPU %d of a total of %d CPUs.", smp_processor_id(), num_online_cpus());
	// Read the address from the APIC Base Address Register of the CPU
	rdmsrl(0x0000001b, lapic_addr);
	// Bits 12-51 contain the pages address. The lowest 12 bits contain
	// additional information about the APIC but are *NOT* part of the
	// address ~~> Mask them to get the address of the physical frame
	lapic_page = ioremap(lapic_addr & (~0xFFFu), 4096);
	
	// We now got the physical address mapped. Let's do the IPI
	pr_info("***KMOD: LAPIC ADDRESS: 0x%016llx MAPPED TO: 0x%016lx\n", lapic_addr & (~0xFFFu), ((size_t)lapic_page));
	pr_info("***KMOD: lapic ID 0x%08x\n", ioread32(lapic_page + 0x20) );
	pr_info("***KMOD: lapic version 0x%08x\n", ioread32(lapic_page + 0x30));

	// Clear APIC errors
	iowrite32(0 , lapic_page + 0x280);
	// Select AP
	iowrite32(
		(ioread32(lapic_page + 0x310) & 0x00ffffff) | (AP_ID << 24),
		lapic_page + 0x310
	);

	// Trigger INIT IPI and wait for delivery
	iowrite32(
		(ioread32(lapic_page + 0x300) & 0xfff00000) | 0x00C500,
		lapic_page + 0x300
	);
	do {
		__asm__ __volatile__ ("pause" : : : "memory"); 
	} while (ioread32(lapic_page + 0x300) & (1 << 12));

	// Select AP again and deassert, then wait for delivery
	iowrite32(
		(ioread32(lapic_page + 0x310) & 0x00ffffff) | (AP_ID << 24),
		lapic_page + 0x310
	);
	iowrite32(
		(ioread32(lapic_page + 0x300) & 0xfff00000) | 0x008500,
		lapic_page + 0x300
	);
	do {
		__asm__ __volatile__ ("pause" : : : "memory"); 
	} while (ioread32(lapic_page + 0x300) & (1 << 12));
	//Wait 10 ms
	udelay(10000);

	// send STARTUP IPI (twice)
	for(num_startups = 0; num_startups < 2; ++num_startups) {
		// Clear errors; Seclect AP; Trigger STARTUP IP; wait
		iowrite32(0, lapic_page + 0x280); 
		iowrite32(
			(ioread32(lapic_page + 0x310) & 0x00ffffff) | (AP_ID << 24),
			lapic_page + 0x310
		);
		// set delivery mode to 0x6 (startup) and vector to 0xc8 (segment of reserved low mem)
		iowrite32(
			(ioread32(lapic_page + 0x300) & 0xfff0f800) | 0x0006c8,
			lapic_page + 0x300
		);
		udelay(200);
		do {
			__asm__ __volatile__ ("pause" : : : "memory");
		} while (ioread32(lapic_page + 0x300) & (1 << 12));
	}
	// Release ressources; Enable interrupts
	iounmap(lapic_page);
	local_irq_restore(flags);
}

struct file *file_open(const char *path, int flags, int rights) 
{
	struct file *filp = NULL;

	int err = 0;

	filp = filp_open(path, flags, rights);
	if (IS_ERR(filp)) {
		pr_info("Error reading file!");
		err = PTR_ERR(filp);
		return NULL;
	}
	return filp;
}

void cleanup_module(void)
{
	purge_tee_chardev();
	printk(KERN_INFO "Goodbye world 1.\n");
}